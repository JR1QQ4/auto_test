# 软件测试

> 极客时间，软件测试52讲，茹炳晟

## 测试基础知识篇

### 01 你真的懂测试吗？从“用户登录”测试谈起

作为测试工程师，你的目标是要保证系统在各种应用场景下的功能使符合设计要求的，所以你需要考虑的测试用例就需要更多、更全面

三个个最常用、最典型的黑盒测试方法:

- 等价类划分方法，是将所有可能的输入数据划分成若干个子集，在每个子集中，如果任意一个输入数据对于揭露程序中潜在错误都具有同等效果，
那么这样的子集就构成了一个等价类。后续只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖
结果
- 边界值分析方法，是选取输入、输出的边界值进行测试。因为通常大量的软件错误是发生在输入或输出范围的边界上，所以需要对边界值进行重点
测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。边界值分析是对等价类划分的补充
- 错误推测方法，是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而由针对性的设计测试用例的
方法。这个方法强调的是对被测软件的需求理解以及设计实现的细节把握，当然还有个人的能力

一个质量过硬的软件系统，除了显式功能性需求以外，其他的非功能性需求，即隐式功能性需求（安全性、性能以及兼容性）也是极其关键的

在绝大多数的软件工程实践中，测试由于受限于时间成本和经济成本，是不可能去穷尽所有可能的组合的，而是采用基于风险驱动的模式，有所侧重
地选择测试范围和设计测试用例，以寻求缺陷风险和研发成本之间的平衡

### 如何设计一个“好的”测试用例？

好的测试用例一定是一个完备的集合，它能够覆盖所有等价类以及各种边界值，而根能否发现缺陷无关。好的测试用例必须具备以下三个特征:

- 整体完备性: 好的测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求
- 等价类划分的准确性: 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过
- 等价类集合的完备性: 需要保证所有可能的边界值和边界条件都已经正确识别

对大多数的软件测试者，综合使用等价类划分、边界值分析和错误推测者三大类方法就足够了

在具体的用例设计时，首先需要搞清楚每一个业务需求所对应的多个软件功能需求点，然后分析出每个软件功能需求点对应的多个测试需求点，最后
再针对每个测试需求点设计测试用例

### 什么是单元测试？如何做好单元测试？

单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进项检查和验证的工作，这里的最小可测试单元通常是指函数或者类

要做好单元测试，你首先必须弄清除单元测试的对象是代码，以及代码的基本特征和产生错误的原因，然后你必须掌握单元测试的基本方法和主要
技术手段，比如什么是驱动代码、桩代码和 Mock 代码等:

- 第一，代码的基本特征与产生错误的原因：
    - 如果要实现正确的功能逻辑，会有哪几种正常的输入
    - 是否由需要特殊处理的多种边界输入
    - 各种潜在非法输入的可能性以及如何处理
- 第二，单元测试用例详解
    - 输入数据种类: 
        - 被测试函数的输入参数
        - 被测试函数内部需要读取的全局静态变量
        - 被测试函数内部需要读取的成员变量
        - 函数内部调用子函数获得的数据
        - 函数内部调用子函数改写的数据
        - 嵌入式系统中，在中断调用时改写的数据
    - 预计输出的分类:
        - 被测试函数的返回值
        - 被测试函数的输出参数
        - 被测试函数所改写的成员变量
        - 被测试函数所改写的全局变量
        - 被测试函数中进行的文件更新
        - 被测试函数中进行的数据库更新
        - 被测试函数中尽心过的消息队列更新
- 第三，驱动代码，桩代码和 Mock 代码
    - 驱动代码（Driver）指调用被测函数的代码，在单元测试过程中，驱动模块通常包括调用北侧函数前的数据准备、调用被测函数以及验证相关
    结果三个步骤。驱动代码的结构，通常由单元测试的框架决定
    - 桩代码（Stub）是用来代替真实代码的临时代码。比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行
    测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码
        - 编写桩代码通常需要遵守以下三个原则:
            - 桩函数要具有与原函数完全相同的原形，仅仅是内部实现不同，这样测试代码才能正确链接到桩函数
            - 用于实现隔离和补充的桩函数比较简单，只需保持原函数的声明，加一个空的实现，目的是通过编译链接
            - 实现控制功能的桩函数是应用最广泛的，要根据测试用例的需要，输出何时的数据作为被测函数的内部输入
    - Mock 代码和桩代码非常类似，都是用来替代真实代码的临时代码，起到隔离和补齐的作用。Mock 代码和桩代码的本质区别是: 测试期待
    结果的验证（Assert and Expectation）
        - 对于 Mock 代码来说，关注点是 Mock 方法有没有被调用，以什么样的参数被调用，被调用的次数，以及多个 Mock 函数的先后调用
        顺序。所以，在使用 Mock 代码的测试中，对于结果的验证（也就是 assert），通常出现在 Mock 函数中
        - 对于桩代码来说，关注点是利用 Stub 来控制被测函数的执行路径，不会去关注 Stub 是否被调用以及怎么样被调用。所以，在使用
        Stub 的测试中，对于结果的验证（也就是 assert），通常出现在驱动代码中
        
### 为什么要做自动化测试？什么样的项目适合做自动化测试？

自动化测试是，把人对软件的测试行为转化为由机器执行测试行为的一种实践，对于最常见的 GUI 自动化测试来讲，就是由自动化测试工具模拟之前
需要人工在软件界面上的各种操作，并且自动验证其结果是否符合预期

当你发现自动化测试用例的维护成本高于其节省的测试成本时，自动化测试就失去了价值与意义，你也就需要在是否使用自动化测试上权衡取舍了

适合自动化测试的项目:

- 第一，需求稳定，不会频繁变更
- 第二，研发和维护周期唱，需要频繁执行回归测试
    - 对于一些中长期项目，对比较稳定的软件功能进行自动化测试，对变动较大或者需求暂时不明确的功能进行手工测试，最终目标是用 20% 的
    精力去覆盖 80% 的回归测试
- 第三，需要在多种平台上反复运行相同测试的场景
- 第四，某些测试项目通过手工测试无法实现，或者手工测试成本太高
- 第五，被测软件的开发较为规范，能够保证系统的可测试性
- 第六，测试人员已经具备一定的编程能力

### 你知道软件开发各阶段都有哪些自动化测试技术吗？

单元测试阶段的自动化不仅仅指测试用例执行的自动化，还应该包含以下五个方面:

1. 用例框架代码生成的自动化
2. 部分测试输入数据的自动化生成
3. 自动桩代码的生成
    - 抽桩，在单元测试阶段，假如函数 A 内部调用的函数 B 是桩代码，那么在代码级集成测试阶段，我们希望函数 A 不再调用假的函数 B，
    而是调用真实的函数 B，这个用真实函数 B 代替原本桩代码函数 B 的操作，就称为 “插桩” 
4. 被测代码的自动化静态分析
5. 测试覆盖率的自动统计与分析

代码级集成测试，是指将已经开发完成的软件模块放在一起测试:

- 代码级集成测试与单元测试最大的区别只是，代码级集成测试中被测函数内部调用的其他函数必须是真实的，不允许使用桩代码代替，而
单元测试中允许使用桩代码来模拟内部调用的其他函数

Web Service 测试的自动化技术，主要是指 SOAP API 和 REST API 这两类 API 测试，最典型的是采用 SoapUI 或 Postman 等类似的工具。但
这类测试工具基本都是界面操作手动发起 Request 并验证 Response，所以难以和 CI/CD 集成，于是就出现了 API 自动化测试框架

Web Service 测试自动化不仅仅包括 API 测试用例执行的自动化，还包括以下四个方面:

1. 测试脚手架代码的自动化生成
2. 部分测试输入数据的自动生成
3. Response 验证的自动化
4. 基于 SoapUI 或者 Postman 的自动化脚本生成

GUI 测试的自动化技术，目前主要分为两个方向，传统 Web 浏览器和移动端原生应用（Native App）的 GUI 自动化。虽然二者采用的具体技术
差别很大，但是用例设计的思路类似:

- 对于传统 Web 浏览器的 GUI 自动化测试，业内主要的开源方案采用 Selenium，商业方案采用 Micro Focus 的 UFT（前身是 HP 的 QTP）
- 对于移动端原生应用，通常采用主流的 Appium，它对 iOS 环境集成了 XCUITest，对 Android 环境集成了 UIAutomator 和 Espresso

### 你真的懂测试覆盖率吗？

测试覆盖率通常被用来衡量测试的充分性和完整性，从广义的角度来讲，测试覆盖率主要分为两大类，一类是面向项目的需求覆盖率，另一类是更
偏向技术的代码覆盖率。现在人们口中的测试覆盖率，通常默认指代码覆盖率，而不是需求覆盖率

三种代码覆盖率指标:

- 行覆盖率又称为语句覆盖率，指已经执行到的语句占总可执行语句的百分比，实际项目中通常会结合判定覆盖率或者条件覆盖率一起使用
- 判定覆盖率又称分支覆盖率，用以度量程序中每一个判定的分支是否都被测试到了，即代码中每个判断的取真分支和取假分支是否各被覆盖
至少各一次。比如，if(a>0 && b>0)，就要求覆盖 “a>0 && b>0” 为 TRUE 和 FALSE 各一次
- 条件覆盖是指，叛党中每个条件的可能取值至少满足一次，度量判定中的每个条件的结果 TRUE 和 FALSE 是否都被测试到了。
比如，if(a>0 && b>0)，就要求 “a>0” 取 TRUE 和 FALSE 各一次，同时要求 “b>0” 取 TRUE 和 FALSE 各一次

统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并由针对性的进行补充，同时还可以识别代码中那些由于需求变更等原因造成的不可达的
废弃代码
 
总结来讲，高的代码覆盖率不一定能保证软件的质量，但是低的代码覆盖率一定不能保证如软件的质量
 
实现代码覆盖率的统计，最基本的方法就是注入（instrumentation）。简单地说，注入就是在被测代码中自动插入用于覆盖率统计地
探针（Probe）代码，并保证插入的探针代码不会给原代码带来任何影响

### 如何高效填写软件缺陷报告？

缺陷报告本身的质量将直接关系到缺陷被修复的速度以及开发工程师的效率，同时还会影响测试工程师的信用、测试与开发人员协作的有效性:

- 缺陷标题通常是别人最先看到的部分，是对缺陷的概括性描述，通常采用 “在什么情况下发生了什么问题” 的模式
- 缺陷概述通常会提供更多概括性的缺陷本质与现象的描述
- 缺陷影响
- 环境配置
- 前置条件
- 缺陷重现步骤是整个缺陷报告中最核心的内容，其目的在于用简洁的语言向开发工程师展示缺陷重现的具体操作步骤
- 期望结果和实际结果
- 优先级（Priority）和严重程度（Severity）
    - 严重程度是缺陷本身的属性，通常确定后不再变化，事情的紧急程度
    - 优先级是缺陷的工程属性，会随着项目进度、解决缺陷的成本等因素而变动，事情的重要程度
- 变通方案（Workaround）
- 根原因分析（Root Cause Analysis）
- 附件（Attachment）

### 以终为始，如何才能做好测试计划？

一份好的测试计划要包括: 测试范围、测试策略、测试资源、测试进度和测试风险评估:

- 测试范围需要明确 “测什么” 和 “不测什么”
- 测试策略需要明确 “先测什么后测什么” 和 “如何来测”
- 测试资源需要明确 “谁来测” 和 “在哪里测”
- 测试进度需要明确各类测试的开始时间，所需工作量和预计完成时间
- 测试风险评估是需要明确如何有效应对各种潜在的变化

### 软件测试工程师的核心竞争力是什么？

把测试工程师按照工作内容，分为了功能测试工程师（即传统测试工程师）和测试开发工程师两类:

- 功能测试工程师，其核心竞争力包括: 测试策略设计能力、测试用例设计能力、快速学习能力、探索性测试思维、缺陷分析能力、自动化测试技术
和良好的沟通能力
- 测试开发工程师，需要具备优秀的测试系统需求分析能力和完备的知识体系

### 软件测试工程师需要掌握的非测试知识由哪些？

软件测试工程师需要掌握非常多的非测试专业知识，包括: 网站架构、容器技术、云计算技术、DevOps思维，以及前端开发技术的核心知识以及实践

### 互联网产品的测试策略应该如何设计？

                                           




## GUI自动化测试篇






## API自动化测试篇






## 代码测试篇






## 性能测试篇






## 测试数据准备篇






## 测试基础框架篇






## 测试新技术篇






## 测试人员的互联网架构核心知识篇






## 特别放送篇






## 测一测






## 结束语






