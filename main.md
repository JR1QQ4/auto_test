# 软件测试

## 理论知识

Bug：格蕾丝·赫柏(Grace Murray Hopper)使用的Mark Ⅱ由于继电器中有一只死掉的蛾子而出现故障。后来"bug"(小虫)和"debug"(除虫)成了计算机领域中特指莫明其妙的"错误"和"排除错误"的专用词汇。

软件测试：为了发现软件中可能存在的错误而运行软件的过程。存在错误、发现错误、运行软件

Bug的三种状态：

- Fault：静态存在于软件中的缺陷
- Error：在运行过程中运行到Fault，出现的一种中间状态
- Failure：失效，Error一直传播到软件外面，用户能观测到这行为

PIE MODEL模型：执行fault -> 出现Error(可能不出现中间状态) -> Failure(可能不出现)

软件测试：为了发现错误而执行软件的过程；从无限的输入中寻找有限的测试用例，并用这些有限的测试用例进行动态验证的方法；为了满足特定的需求规约而对软件进行分析和评价的过程。

测试用例：输入、期望输出、环境要素

测试：为了发现错误而执行软件的过程
调试：发现了错误去修改的过程

确认：是个外部过程，用户来判断软件的质量、功能等是否符合要求
验证：更多是一个内部的过程，开发组织内部对软件测试查看是否符合规约

常见的测试技术分类：

- 基于直觉/经验的测试技术：个人经验、探索测试
- 基于输入域的测试技术：等价类、边界值、随机测试、组合测试
- 基于代码的测试技术：代码抽象的方法、基于控制流、基于数据流
- 基于错误的测试技术：错误猜测法、变异测试
- 基于模型的测试技术：决策表、有限状态机、形式化规约、工作流模型
- 基于使用的测试技术
- 基于应用特性的测试技术

覆盖率：

- 结构覆盖：语句覆盖率、分支覆盖率
- 逻辑覆盖：判定覆盖率、条件覆盖率、判定条件覆盖率、条件组合覆盖率
- 路径覆盖：路径覆盖率；循环路径，基本路径测试
- 数据流覆盖

程序环路复杂性计算方法(3种)：
(1)流程图中区域的数量对应于环形复杂度
(2)给定流图G的环形复杂度V(G)，定义为V(G)=E-N+2，E是图中边的数量，N是图中节点的数量
(3)V(G)=P+1，P是流图G中的判定节点数

## Linux

### grep、sed、awk

grep: 根据用户指定的模式(pattern)对目标文本进行过滤，显示被模糊匹配到的行

- `grep -n root passwd.txt`，显示行号
- `grep -v root passwd.txt`，反选
- `grep ^root passwd.txt`，`grep root$ passwd.txt`，开始与结尾

sed: 是流编辑器，一次处理一行内容，行存储在模式空间中

- `sed -e '1 a drink tea' passwd.txt`，a 标识添加，1 表示行号，drink tea 表示追加的文本，源文件不会改变，可以使用重定向保存
- `sed -e '2i newline' passwd.txt`，在第 2 行前面插入 newline，`-e` 后面接的就是需要执行的脚本
- `sed -e 's/root/hello/g' passwd.txt`，全局替换，把 root 替换成 hello
- `sed -e '2,5c No 2-5 number' passwd.txt`，第 2 行到第 5 行会被 No 2-5 number 取代
- `sed -i "50,60d" passwd.txt`，`-i` 会修改源文件，删除50到60行的内容并保存修改后的文件
- `sed -n '/root/p' passwd.txt`，会打印包含 root 的行

awk: 把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行后续处理

- 把行作为输入，并赋值给`$0` -> 将行切段，从 `$1` 开始 -> 对行匹配正则/执行动作 -> 打印内容
- 常用参数:
	- FILENAME，awk 浏览的文件名
	- BEGIN，处理文本之前要执行的操作
	- END，处理文本之后要执行的操作
	- FS，设置输入域分隔符，等价于命令行 -F 选项
	- NF，浏览器记录的域的个数（列数）
	- NR，已读的记录数（行数）
	- OFS，输出域分隔符; ORS，输出记录分隔符; RS，控制记录分隔符
	- `$0` 表示一整行内容; `$1` 表示第一个匹配到的内容，即索引从 1 开始
- `awk -F: '/root/ {print $0}' passwd.txt`，搜索文件中包含 root 的所有行，并按照 `:` 把匹配到的内容分割，打印每行
- `awk -F: '/root/ {print $7}' passwd.txt`，搜索文件中包含 root 的所有行，并按照 `:` 把匹配到的内容分割，打印内容中的第 7 段
- `awk -F: 'NR==2{print $0}' passwd.txt`，打印文件中第 2 行的内容
- `awk -F: 'BEGIN {print "BEGIN awk"} {print $1, $7}' passwd.txt`，打印标题 BEGIN awk，然后打印匹配到的第 1 列和第 7 列
- `echo "111 222|333 444|555 666" | awk 'BEGIN{RS="|"} {print $0}'`，默认会有 `-F ""` 空行分隔符，这里自定义分隔符为 |











